## Understanding JWT (JSON Web Tokens)

## 什么是 JWT

> 原文地址: <http://polyglot.ninja/understanding-jwt-json-web-tokens/>
**本文版权归原作者所有，翻译仅用于学习。**

---------

In the end of our last post (which was about [Securing REST APIs](http://polyglot.ninja/securing-rest-apis-basic-http-authentication-python-flask/)) we mentioned about JWT. I made a promise that in the next post, we would discuss more about JWT and how we can secure our REST APIs using it. However, when I started drafting the post and writing the code, I realized the underlying concepts of JWT themselves deserve a dedicated blog post. So in this blog post, we will focus solely on JWT and how it works.

在上篇文章（[安全的 REST API](http://polyglot.ninja/securing-rest-apis-basic-http-authentication-python-flask/)）结束的时候我们提到了 JWT。我承诺在下一篇文章中，我们会讨论更多的 JWT 相关内容，并学习如何在 REST API 中使用 JWT。然而，当我开始起草这篇文章和写代码的时候。我才真正的理解了 JWT 底层的概念，为此我需要专门写一篇文章。在这篇文章中，我们只会关注 JWT 和它的工作原理。

### What is JWT?

We will ignore the text book definitions and try to explain the concepts in our own words. Don’t be afraid of the serious looking acronym, the concepts are rather simple to understand and comprehend. First let’s break down the term – “JSON Web Tokens”, so it has to do something with JSON, the web and of course tokens. Right? Let’s see.

我们会忽略课本上的定义，尝试用通熟易懂的语言来解释。不要被它的缩写吓到。这些概念相当容易理解。首先，让我们看看它的全称 - “JSON Web Tokens”，字面意思就是：对 JSON、网络、令牌做了什么，对吧？让我们接着看。

Yes, a JWT mostly concerns with a Token that is actually a hashed / signed form of a JSON payload. The JSON payload is signed using a hashing algorithm along with a secret to produce a single (slightly long) string that works as a token. So a JWT is basically a string / token generated by processing a JSON payload in a certain way.

是的，JWT 其实就是对 JSON 加密签名后生成的一个令牌。JSON 用哈希算法和密钥生成一个长字符串作为令牌。所以，JWT 其实就是通过某种方式处理 JSON 生成令牌的方法。

So how does JWT help? If you followed our last article, you now know why http basic auth is bad. You have to pass your username and password with every request. That is kind of bad, right? The more you send your username and password over the internet, the more likely it is to get compromised, no? Instead, on the first login, we can accept the username and password and return a token back to the client. The client passes that token with every request. We verify that token to see if it’s a logged in user or not. This is the idea behind **Token** based authentication.

它有什么用呢？如果，你有看过我们的上一篇文章，你就会知道 http 的身份校验非常糟糕。你每一个请求都必须传递用户名和密码。这很糟糕，对吧？你通过网络传输用户名和密码次数越多，受的威胁就越多，是吧？相反，在第一次登录的时候，我们可以接收用户名和密码并返回给客户端一个令牌。客户端在以后请求中带上令牌。我们就可以校验令牌是否有效。这就是基于**令牌**进行身份校验的背景。

### Random Tokens  vs JWT

How would you generate such token? You could generate a nice random string and store it in database against that user. Right? This is how cookie based session works too, btw. Now what if your application is scaled across multiple servers and all requests are load balanced? One server will not recognize a token / session generated by another server. Unless of course you also have one central database active all the time, serving all the incoming requests from all the servers. That setup is tricky and difficult, no?

我们如何生成令牌呢？你可以生成一个随机字符串并把它和用户关联存储在数据库中，对吧？顺便说一句，这就是 session 的工作原理。如果，你的应用部署在多台服务器上并且需要负载均衡？其中的一台服务器并不会认识另外一台服务器生成的令牌／会话。除非你把所有的请求都存储在一个数据库中。这实现起来非常的困难棘手，不是吗？

There is another work around using sticky sessions where the requests from one particular user is always directed to the same server by the load balancer. This work around is also not as simple as JWT. Even if all these work nicely, we still have to make database queries to validate the token / session. What if we want to provide single sign on (users from one service wants to access resources on a different service all together)? How does that work? We will need a central auth server and all services will have to talk to it to verify the user token.

假如，某个特定用户的请求都被分配到同一个服务器，这也是我们使用 sessions 时需要注意的。它的解决方案也并不会像 JWT 那么简单。为了能实现以上方案，我们还是需要去数据库查询校验令牌／会话。我们如何实现单点登录呢(一台服务上的用户可以访问其他服务器上的资源)？它的工作原理是什么呢？我们需要一个服务器验证身份并把身份共享到其他服务器。

The benefit of JWT is that it’s lightweight but at the same time it’s a self contained JSON payload. You can store user identity in the JSON, sign it and send the token to the clients. Since it’s **signed** we can verify and validate it with just our secret key. No database overhead. No need for sticky sessions. Just share the secret key privately and all your services can read the data stored inside the JWT. Others can’t tamper or forge a new, valid token for an user without that secret key. Single sign on just becomes a breeze and less complicated. Sounds good? Let’s see how JWTs are constructed.

JWT 不但轻量，同时它自身也是一个 JSON 载体。你可以把用户身份信息存储在里面，签名然后把令牌返回给客户端。一旦签名成功，我们只需用安全秘钥验证即可。不需要数据库。不需要 session。只需把私有秘钥在服务器之间共享，然后所有的服务器就可以访问存储在 JWT 中的数据了。其他人也不能为没有私钥的用户篡改和生成新的令牌。单点登录变的轻而易举，听起来不错！让我们看看 JWT 是如何工作的。

### Anatomy of JWT

A JSON Web Token consists of three major parts:

JWT 包含三个主要部分：

- Header
- Payload
- Signature

- 头部
- 载体
- 签名

These 3 parts are separated by dots (.). So a JWT looks like the following

这三部分用点（.）连接。因此 JWT 看起来如下所示：

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
```

If you look closely, there are 3 parts here:

如果，你仔细看，会发现有三部分：

- **Header:** ```eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9```
- **Payload:** ```eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9```
- **Signature:** ```TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ```

- **头部:** ```eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9```
- **载体:** ```eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9```
- **签名:** ```TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ```

Okay, so we get the three parts, but what do they really do? Also those strings look like meaningless characters to me. What are they? How are they generated? Well, they are encoded in certain ways as we will see in the following sections.

好了， 我们已经看到了这三部分，但是它们到底是什么呢？这些字符串在我看来就是无意义的字符串。它们是什么呢？如何生成呢？好了，在接下来的章节中我们会看到它们是如何生成的。

### Header

The header is a simple key value pair (dictionary / hashmap) data structure. It usually has two keys ```typ``` and ```alg``` short for type and algorithm. The standard is to have the keys at best 3 character long, so the generated token does not get too large.

头部就是一个简单的健值对（字典／哈希表）数据结构。它通常包括两个键：```typ``` 和 ```alg```，分别是类型和算法的简称。规范规定键最长有 3 个字符，因此生成的令牌也不会太长。

Example:

例如：

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

The ```typ``` value is ```JWT``` since this is JWT we’re using. The ```HS256``` is the most common and most popular hashing algorithm used with JWT.

JWT 中 ```typ``` 的值一定是 ```JWT```。```HS256``` 是 JWT 中用到的最流行的哈希算法。

Now we just need to base64 encode this part and we get the header string. You were wondering why the strings didn’t make sense. That’s because the data is base64 encoded.

我们只需把这部分用 base64 编码，我们就可以得到 JWT 的头部。这就是为什么这串字符串看起来没什么意义。

### Payload

Here comes our favorite part – the JSON payload. In this part, we put the data we want to store in the JWT. As usual, we should keep the keys and the overall structure as small as possible.

载体是最有意义的一部分。在这部分，我们可以存储任何我们想存储的数据。通常，我们会尽可能的保证键和整体结构足够的小。

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
```

We can add any data we see fit. These fields / keys are called “claims”. There are some **reserved claims** – keys which can be interpreted in a certain way by the libraries which decode the JWT. For example, if we pass the ```exp```  (expiry) claim with a timestamp, the decoding library will check this value and throw an exception if the time has passed (the token has expired). These can often be helpful in many cases. You can find the [common standard fields](https://en.wikipedia.org/wiki/JSON_Web_Token#Standard_fields) on Wikipedia.

我们可以添加任何个人认为合理的数据。这些健值对称为“声明”。有一些**保留字段** - 它们可以被 JWT 的解码库以某种特定方式解读。例如，我们用一个时间戳声明 ```exp```(到期)，解码库会校验它的值，如果已经超时（令牌已失效）就会抛出异常。在很多实例中这非常有用。在维基百科上你可以找到这些[常用的标准字段](https://en.wikipedia.org/wiki/JSON_Web_Token#Standard_fields)。

As usual, we base64 encode the payload to get the payload string.

通常，我们会对载体进行 base64 编码得到载体字符串。

### Signature

The signature part itself is a hashed string. We concatenate the header and the payload strings (base 64 encoded header and payload) with a dot (```.```) between them. Then we use the hashing algorithm to hash this string with our secret key.

签名本身就是一个哈希字符串。我们用 ```.``` 连接头部和载体字符串（需要分别进行 base64 编码）。然后用我们的私钥配合哈希算法对字符串进行哈希处理。

In pseudocode:

伪代码：

```js
concatenated_string = base64encode(header) + '.' + base64encode(payload)
signature = hmac_sha256(concatenated_string, 'MY_SUPER_SECRET_KEY')
```

That would give us the last part of the JWT, the signature.

这就是 JWT 中的最后的部分 - 签名。

### Glue it all together

As we discussed before, the JWT is the dot separated form of the three components. So the final JWT would be:

正如我们所说，JWT 是由 3 部分组成分别用圆点 ```.``` 连接。所以，最终看起如下所示：

```js
jwt = header + "." + payload + "." + signature
```

### Using a library

Hey! JSON Web Tokens sounded great but looks like there’s a lot of work involved! Well, it would seem that way since we tried to understand how a JSON Web Token is actually constructed. In our day to day use cases, we would just use a suitable library for the language / platform of our choice and be done with it.

JWT 听起来非常美好，但还是有些工作需要处理！好了，看起来我们已经理解了 JWT 的工作原理了。在我们的日常开发中，我们应该选择一个适当的库去实现。

If you are wondering what library you can use with your language / platform, here’s a comprehensive list of libraries – [JSON Web Token Libraries](https://jwt.io/#libraries).

如果，你想知道你熟悉的语言/平台有什么库可以使用，这有一个 [JWT 库](https://jwt.io/#libraries)的列表。

### Real Life Example with PyJWT

Enough talk, time to see some codes. Excited? Let’s go!

说的太多了，是时候写写代码了。激动吧？我们开始吧！

We will be using Python with the excellent [PyJWT](https://github.com/jpadilla/pyjwt/) package to encode and decode our JSON Web Tokens in this example. Before we can use the library, we have to install it first. Let’s do that using ```pip```.

在实例中我们将使用 Python 配合 [PyJWT](https://github.com/jpadilla/pyjwt/) 进行编码和解码 JWT。在使用前，首先我们需要安装它。让我们用 ```pip``` 安装。

```sh
pip install pyjwt
```

Now we can start generating our tokens. Here’s an example code snippet:

现在我们可以生成令牌。这里只是代码片段：

```Python
import jwt
import datetime

payload = {
    "uid": 23,
    "name": "masnun",
    "exp": datetime.datetime.utcnow() + datetime.timedelta(minutes=2)
}

SECRET_KEY = "N0TV3RY53CR3T"

token = jwt.encode(payload=payload, key=SECRET_KEY)

print("Generated Token: {}".format(token.decode()))

decoded_payload = jwt.decode(jwt=token, key=SECRET_KEY)

print(decoded_payload)
```

If we run the code, we will see:

如果，我们执行代码，会看到：

```js
python jwt_test.py
Generated Token: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1aWQiOjIzLCJuYW1lIjoibWFzbnVuIiwiZXhwIjoxNDk0NDQ5OTQ0fQ.49okXifPSqc7n_n7wZRc9XVVqekTTeBIBBZdiH0nGJQ
{'uid': 23, 'name': 'masnun', 'exp': 1494449944}
```

So it worked – we encoded a payload and then decoded it back. All we needed to do is to call ```jwt.encode``` and ```jwt.decode``` with our secret key and the payload / token. So simple, no? parties.

我们先对载体编码，然后解码。这所有操作我们只需调用 ```jwt.encode``` 和 ```jwt.decode```。非常简单，是吧？

### Bonus Example – Expiry

In the following example, we will set the expiry to only 2 seconds. Then we will wait 10 seconds (so the token expires by then) and try to decode the token.

接下来的实例中，我们设置过期时间仅为 2s。然后，等待 10s(这样我们的令牌将会失效)并尝试解码令牌。

```Python
import jwt
import datetime
import time

payload = {
    "uid": 23,
    "name": "masnun",
    "exp": datetime.datetime.utcnow() + datetime.timedelta(seconds=2)
}

SECRET_KEY = "N0TV3RY53CR3T"

token = jwt.encode(payload=payload, key=SECRET_KEY)

print("Generated Token: {}".format(token.decode()))

time.sleep(10)  # wait 10 secs so the token expires

decoded_payload = jwt.decode(jwt=token, key=SECRET_KEY)

print(decoded_payload)
```

What happens after we run it? This happens:

执行代码会发生呢？以下就是结果：

```sh
jwt.exceptions.ExpiredSignatureError: Signature has expired
```

Cool, so we get an error mentioning that the signature has expired by now. This is because we used the standard ```exp``` claim and our library knew how to process it. This is how we use the standard claims to ease our job!

很棒，我们会得到一个签名过期的错误提示。这是因为我们用了规范中的 ```exp``` 声明，我们的库知道如何处理它。这就是如何使用规范中的声明来简化我们的工作。

### Using JWT for REST API Authentication

Now that we’re all convinced of the good sides of JSON Web Tokens, the question comes into mind – how can we use it in our REST APIs?

现在，我们都知道了 JWT 的好处，但是问题来了 - 如何在 REST API 中使用呢？

The idea is simple and straightforward. When the user logs in the first time, we verify his/her credentials and generate a JSON Web Token with necessary details. Then we return this token back to the user/client. The client will now send the token with every request, as part of the authorization header.

想法非常简单直接。当用户第一次登录时，我们校验他／她的身份并用必要的数据生成令牌。然后把令牌返回给用户／客户端。之后，客户端的每个请求都会带上令牌。

The server will decode this token and read the user data. It won’t have to access the database or contact another auth server to verify the user details, it’s all inside the decoded payload.  And since the token is signed and the secret key is “secret”, we can trust the payload.

服务器将会解码令牌并读取用户数据。它不需要访问数据库，也不用访问另外的服务验证用户信息，用户信息已经包含在里面了。因为令牌已经用私钥签名过，所以数据是可以信任的。

But please make sure the secret key is not compromised. And of course use SSL (https) so that men in the middle can not hijack the token anyway.

但是，请确保私钥不要被泄漏。当然，可以使用 https，这样任何人都不能劫持我们的令牌了。

### What's next?

JSON Web Token is not only about authentication. You can use it to securely transmit data from one party to another. However, it’s mostly used for authenticating REST APIs. In our next blog post, we shall go through that use case. We will see how we can authenticate our api using JWT.

JWT 只是用来认证的。你可以用它来安全的传递数据。然而，大部分情况下我们用它来做 REST API 的身份认证。在下篇文章中，我们会讨论如何使用它，看看如何用 JWT 来实现身份认证。

In the mean time, you can subscribe to the mailing list so you can stay up to date with this blog. If you liked the article and/or learned something new, please don’t forget to share it with your friends.

同时，你可以订阅我们的博客，这样你就可以及时收到博客的更新了。如果，你喜欢我们的博客或者学到了新的知识，别忘记把博客分享给你的朋友们。






